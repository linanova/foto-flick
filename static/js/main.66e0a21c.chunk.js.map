{"version":3,"sources":["index.js"],"names":["Block","style","this","props","correctPosition","getImageStyle","image","className","onClick","React","Component","Board","i","key","blocks","pos","push","renderBlock","Game","positions","a","length","j","Math","floor","random","shuffle","state","hole","getImage","xhttp","XMLHttpRequest","onload","photo","JSON","parse","response","photos","setState","url","url_z","url_o","width","width_z","width_o","height","height_z","height_o","open","send","block","verticallyAdjacent","holeIsRightmost","PUZZEL_BLOCK_SIZE","isAdjacent","slice","isComplete","status","handleClick","xOffset","yOffset","undefined","trunc","size","backgroundImage","backgroundSize","backgroundPosition","ReactDOM","render","document","getElementById"],"mappings":"qPASMA,G,qLAIF,IAAMC,EARY,IAQJC,KAAKC,MAAMC,gBACrBC,EAAcH,KAAKC,MAAMG,MAAOJ,KAAKC,MAAMC,iBAC3C,GACJ,OACE,4BACEG,UAAU,eACVC,QAASN,KAAKC,MAAMK,QACpBP,MAAOA,Q,GAXKQ,IAAMC,YAkBpBC,E,0KACQC,GAAI,IAAD,OACb,OAAQ,kBAACZ,EAAD,CACNa,IAAKD,EACLR,gBAAiBF,KAAKC,MAAMW,OAAOF,GACnCJ,QAAS,kBAAM,EAAKL,MAAMK,QAAQI,IAClCN,MAAOJ,KAAKC,MAAMG,U,+BAMpB,IADA,IAAIQ,EAAS,GACJC,EAAM,EAAGA,EAAM,EAAGA,IACzBD,EAAOE,KAAKd,KAAKe,YAAYF,IAG/B,IAAMd,EAAQI,EAAcH,KAAKC,MAAMG,OACvC,OAEI,yBAAKC,UAAU,mBACb,yBAAKA,UAAU,wBAAwBN,MAAOA,IAC7Ca,O,GArBSL,IAAMC,WA4BpBQ,E,kDACJ,aAAe,IAAD,sBACV,eAEA,IAAIC,EAAY,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAHrB,OAsFhB,SAAiBC,GACf,IAAK,IAAIR,EAAIQ,EAAEC,OAAQT,EAAGA,IAAK,CAC7B,IAAIU,EAAIC,KAAKC,MAAMD,KAAKE,SAAWb,GADN,EAEV,CAACQ,EAAEE,GAAIF,EAAER,EAAI,IAA/BQ,EAAER,EAAI,GAFsB,KAElBQ,EAAEE,GAFgB,MAnF3BI,CAAQP,GACRA,EAAUH,KAxDM,GA0DhB,EAAKW,MAAQ,CACXb,OAAQK,EACRS,KA5Dc,EA6DdtB,MAAO,IAGT,EAAKuB,WAbK,E,uDAgBF,IAAD,OACLC,EAAQ,IAAIC,eAChBD,EAAME,OAAS,WACb,IACIC,EADQC,KAAKC,MAAML,EAAMM,UACbC,OAAOJ,MAAM,GAI7B,EAAKK,SACH,CAAChC,MAAO,CACNiC,IAAKN,EAAMO,OAASP,EAAMQ,MAC1BC,MAAOT,EAAMU,SAAWV,EAAMW,QAC9BC,OAAQZ,EAAMa,UAAYb,EAAMc,aAGtCjB,EAAMkB,KAAK,MAAO,+KAClBlB,EAAMmB,S,kCAGIrC,GACV,GA8DJ,SAAoBsC,EAAOtB,GACzB,IAAIuB,EAAqBD,IAAUtB,EApJX,GAoJuCsB,IAAUtB,EApJjD,EAuJpBwB,EAAkBxB,EAvJE,IAuJ2ByB,EAGnD,QAJqBzB,EAtJG,IAsJ0B,IAEHsB,IAAUtB,EAAO,IAAQwB,GAAmBF,IAAUtB,EAAO,GAE7EuB,EArExBG,CAAW1C,EAAGV,KAAKyB,MAAMC,MAA9B,CAIA,IAAMd,EAASZ,KAAKyB,MAAMb,OAAOyC,QAC7BC,EAAW1C,KAIfA,EAAOZ,KAAKyB,MAAMC,MAAQd,EAAOF,GACjCE,EAAOF,GAjGW,EAkGlBV,KAAKoC,SAAS,CAACxB,OAAQA,EAAQc,KAAMhB,Q,+BAG7B,IAEJ6C,EAFG,OASP,OALEA,EAHeD,EAAWtD,KAAKyB,MAAMb,QAG5B,YAEA,0CAIT,yBAAKP,UAAU,QACb,yBAAKA,UAAU,mCAAf,gBACA,yBAAKA,UAAU,8BACb,kBAACI,EAAD,CACEG,OAAQZ,KAAKyB,MAAMb,OACnBR,MAAOJ,KAAKyB,MAAMrB,MAClBE,QAAS,SAAAI,GAAC,OAAI,EAAK8C,YAAY9C,OAGnC,yBAAKL,UAAU,uCAAf,IAAuDkD,EAAvD,U,GAtEWhD,IAAMC,WAkHzB,SAAS8C,EAAW1C,GAGlB,IAAK,IAAIF,EAAI,EAAGA,EAAIE,EAAOO,OAAS,EAAGT,IACrC,GAAIE,EAAOF,KAAOA,EAChB,OAAO,EAGX,OAAO,EAST,SAASP,EAAcC,EAAOF,GAC5B,IAAIuD,EAAU,EACVC,EAAU,OAIUC,IAApBzD,IACFuD,EAAWvD,EA1LW,GADA,IA4LtBwD,GA5LsB,IA4LZrC,KAAKuC,MAAM1D,EA3LC,IA8LxB,IAAM2D,EAAOzD,EAAMoC,MAAQpC,EAAMuC,OAAS,aAAe,aACzD,MAAO,CACLmB,gBAAgB,OAAD,OAAS1D,EAAMiC,IAAf,KACf0B,eAAgBF,EAChBG,mBAAmB,GAAD,OAAKP,EAAL,cAAkBC,EAAlB,OApEtBO,IAASC,OACP,kBAAClD,EAAD,MACAmD,SAASC,eAAe,W","file":"static/js/main.66e0a21c.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bulma/css/bulma.css'\n\nconst HOLE_POSITION = 8;\nconst PUZZLE_PIXEL_SIZE = 132;\nconst PUZZEL_BLOCK_SIZE = 3;\n\nclass Block extends React.Component {\n  render() {\n\n    // the hole block should not have any background style\n    const style = this.props.correctPosition !== HOLE_POSITION\n      ? getImageStyle(this.props.image, this.props.correctPosition)\n      : {};\n    return (\n      <button\n        className=\"puzzle-block\"\n        onClick={this.props.onClick}\n        style={style}\n      >\n      </button>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  renderBlock(i) {\n    return (<Block\n      key={i}\n      correctPosition={this.props.blocks[i]}\n      onClick={() => this.props.onClick(i)}\n      image={this.props.image}\n    />);\n  }\n\n  render() {\n    let blocks = []\n    for (let pos = 0; pos < 9; pos++) {\n      blocks.push(this.renderBlock(pos))\n    }\n\n    const style = getImageStyle(this.props.image);\n    return (\n\n        <div className=\"board container\">\n          <div className=\"full-image is-overlay\" style={style}></div>\n          {blocks}\n        </div>\n\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor() {\n      super();\n\n      let positions = [0,1,2,3,4,5,6,7]\n      shuffle(positions)\n      positions.push(HOLE_POSITION)\n\n      this.state = {\n        blocks: positions,\n        hole: HOLE_POSITION,\n        image: {},\n      };\n\n      this.getImage();\n  }\n\n  getImage() {\n    let xhttp = new XMLHttpRequest();\n    xhttp.onload = () => {\n      const obj = JSON.parse(xhttp.response);\n      let photo = obj.photos.photo[0]\n\n      // try to use a medium size of the image (640 on the longest size)\n      // if unavailable, use the original image size\n      this.setState(\n        {image: {\n          url: photo.url_z || photo.url_o,\n          width: photo.width_z || photo.width_o,\n          height: photo.height_z || photo.height_o }\n        });\n    }\n    xhttp.open(\"GET\", \"https://api.flickr.com/services/rest/?method=flickr.photos.getRecent&api_key=ff9496e0e983b050641d2dd10fefcc37&extras=url_z%2C+url_o&per_page=1&format=json&nojsoncallback=1\");\n    xhttp.send();\n  }\n\n  handleClick(i) {\n    if (!isAdjacent(i, this.state.hole)) {\n      return;\n    }\n\n    const blocks = this.state.blocks.slice();\n    if (isComplete(blocks)) {\n      return;\n    }\n\n    blocks[this.state.hole] = blocks[i];\n    blocks[i] = HOLE_POSITION;\n    this.setState({blocks: blocks, hole: i});\n  }\n\n  render() {\n    const complete = isComplete(this.state.blocks);\n    let status\n    if (complete) {\n      status = 'Good Job!'\n    } else {\n      status = \"Move the Blocks to Complete the Puzzle!\"\n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"title section has-text-centered\"> foto flick </div>\n        <div className=\"game-board hero is-primary\">\n          <Board\n            blocks={this.state.blocks}\n            image={this.state.image}\n            onClick={i => this.handleClick(i)}\n          />\n        </div>\n        <div className=\"game-info section has-text-centered\"> {status} </div>\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\n/**\n * Shuffles array in place.\n * @param {Array} a The array to shuffle.\n */\nfunction shuffle(a) {\n  for (let i = a.length; i; i--) {\n    let j = Math.floor(Math.random() * i);\n    [a[i - 1], a[j]] = [a[j], a[i - 1]];\n  }\n}\n\n/**\n* Checks if block position is adjacent to hole position on the board.\n* @param {Number} block The current position of the block to check.\n* @param {Number} hole The current position of the hole.\n*/\nfunction isAdjacent(block, hole) {\n  let verticallyAdjacent = block === hole - PUZZEL_BLOCK_SIZE || block === hole + PUZZEL_BLOCK_SIZE\n\n  let holeIsLeftmost = hole % PUZZEL_BLOCK_SIZE === 0\n  let holeIsRightmost = hole % PUZZEL_BLOCK_SIZE === PUZZEL_BLOCK_SIZE - 1\n  let horizontallyAdjacent = (!holeIsLeftmost && block === hole - 1) || (!holeIsRightmost && block === hole + 1)\n\n  return horizontallyAdjacent || verticallyAdjacent\n}\n\n/**\n* Checks if all the blocks are in the correct position.\n* @param {Array} blocks The array describing the current position of blocks.\n* @returns {Boolean} True if the puzzle is complete.\n*/\nfunction isComplete(blocks) {\n  // Puzzle is complete when each block value (correct position)\n  // equals the block index (current position)\n  for (let i = 0; i < blocks.length - 1; i++) {\n    if (blocks[i] !== i) {\n      return false;\n    }\n  }\n  return true\n}\n\n/**\n* Computes style for the image properties and block position given.\n* @param {Object} image The image properties - url, width, height.\n* @param {Number} correctPosition If defining style for a block, specifies the correct position of that block in the original image.\n* @returns {Object} The computed style.\n*/\nfunction getImageStyle(image, correctPosition) {\n  let xOffset = 0\n  let yOffset = 0\n\n  // if no position was specified, we are not dealing with a block\n  // so we don't need to adjust the image offset\n  if (correctPosition !== undefined) {\n    xOffset = (correctPosition % PUZZEL_BLOCK_SIZE) * (-PUZZLE_PIXEL_SIZE);\n    yOffset = Math.trunc(correctPosition/PUZZEL_BLOCK_SIZE) * (-PUZZLE_PIXEL_SIZE);\n  }\n\n  const size = image.width < image.height ? '396px auto' : 'auto 396px';\n  return {\n    backgroundImage: `url(${image.url})`,\n    backgroundSize: size,\n    backgroundPosition: `${xOffset}px ${yOffset}px`\n  };\n}\n"],"sourceRoot":""}